file 	装入想要调试的可执行文件.
kill 	终止正在调试的程序.
list 	列出产生执行文件的源代码的一部分.
next 	执行一行源代码但不进入函数内部.
step 	执行一行源代码而且进入函数内部.
run 	执行当前被调试的程序
quit 	终止 gdb
watch 	使你能监视一个变量的值而不管它何时被改变.
break 	在代码里设置断点, 这将使程序执行到这里时被挂起.
make 	使你能不退出 gdb 就可以重新产生可执行文件.
shell 	使你能不离开 gdb 就执行 UNIX shell 命令. 

===============================================================================
backtrace
main()->func1()->func2()->func3()->.....
bt n	列出函数调用信息 func3() func2() ...
bt -n	列出函数调用信息 main() func1() ...

bt full
bt full n
bt full -n
		列出函数调用信息的同时列出局部变量

set backtrace past-main
set backtrace past-main on
		越过程序入口（main）继续向前跟踪
set backtrace past-main off
		跟踪到（main）便停止
show backtrace past-main
		显示是否越过main进行跟踪
et backtrace past-entry
set backtrace past-entry on
        Backtraces will continue past the internal entry point of an
		application. This entry point is encoded by the linker when 
		the application is built, and is likely before the user entry
		point main (or equivalent) is called.
set backtrace past-entry off
        Backtraces will stop when they encounter the internal entry
		point of an application. This is the default. show backtrace
		past-entry Display the current internal entry point backtrace
		policy.

set backtrace limit n
set backtrace limit 0
		设置跟踪层数限制，0意味着没有限制
show backtrace limit
		显示当前跟踪层数限制

main()
func1()
func2()
func3()
frame n
f n
		选择帧栈n
frame addr
f addr
		选择地址位于addr的帧栈
up n	在堆栈中上移n个帧栈;当前帧栈为func3(),则 up 3->main()
down n  在堆栈中下移n个帧栈;当前帧栈为main(), 则 down 2->func2()

up-silently n
down-silently n
		功能跟up,down一样，只不过悄悄的进行工作。主要用于gdb命令脚本，这时
		没有必要输出
		
frame
f		输出当前帧栈信息

info frame
info f	输出当前帧栈详细信息
			帧栈地址
			下个帧栈地址（本帧栈调用的函数）
			上个帧栈地址（调用本函数的函数地址)
			帧栈所在的源文件语言类型
			帧栈参数所在的地址
			帧栈局部变量地址
			帧栈保存的程序计数器
			哪个寄存器被保存在帧栈内
info frame addr
info f addr
info args
info locals
info catch	输出当前帧栈当前执行点所有的异常捕获处理信息

===============================================================================
break location<v>
break		在当前选择的帧栈（见backtrace）的下一个指令处设置断点
break ... if cond<v>
tbreak args
hbreak args
thbreak args
rbreak regex<v>
			挑选符合正则表达式regex的函数，设置断点
info breakpoints [n]
info break [n]
info watchpoints [n]
			输出所有的断点、观察断点、异常抛出的信息。若设置可选参数n，则只输出
			编号为n的断点（观察断点、异常抛出断点）的信息
			输出信息内容：
				Type					断点类型
				Disposition(Disp)		断点执行完毕后是否继续保留该断点
				Enable or Disabled(Enb)	断点是否起作用
				Address					断点位置(未决断点显示<PENDING>,如共享库)
				What					断点于程序源文件中的位置
set breakpoint pending auto
			当GDB找不到断点位置时，它会向你询问是否设置未决断点
set breakpoint pending on
			若断点位置未知，则自动创建未决断点
set breakpoint pending off
			表明不创建未决断点。任何位置未知的断点将会导致错误。该设置对已经设置
			的未决断点不会产生影响
show breakpoint pending
			显示创建未决断点时的动作（创建成功还是导致错误）

对于由命令hbreak设置的断点，GDB会始终是用硬件断点（hardware breakpoints）

set breakpoint auto-hw on
			默认设置。当设置断点时，GDB会尝试使用目标内存映射来判断是使用软断点
			还是硬断点 （software or hardware breakpoint）
set breakpoint auto-hw off
			指示GDB不要自动选择断点类型。如果目标提供了内存映射，GDB会发出警
			告：设置断点于只读地址（set software breakpoint at a read-only
			 address）

watch expr<v> [thread threadnum<v>]
			设置断点。当程序写入表达式expr<v>并且值改变的时候，中断程序运行。可
			以简单的使用该命令来监视单个变量的值
				(gdb) watch foo
			如果该命令附带thread threadnum<v>，仅当线程号为threadnum<v>的线程改
			变expr<v>的值时，GDB才中断程序执行。这种仅限于单个线程的断点只能应
			用于硬件断点
rwatch expr<v> [thread threadnum<v>]
			程序读取expr<v>的值时，打断程序执行
awatch expr<v> [thread threadnum<v>]
			程序读写expr的值时，打断程序执行
info watchpoints
			功能等同于info break
